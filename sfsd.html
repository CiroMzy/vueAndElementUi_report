<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h3>jwt的构成</h3>
<p>jwt分成三个部分，前两部分是base64转码的字符串，第三部分是通过前两部分和一个密钥，进行加密生成的。</p>
<ul>
  <li>第一部分$header基本上是固定的，不用改它，就是个声明。</li>
  <li>$playload是涉及到的参数，都是自定义的，转成base64，基本上跟明文没什么区别。就是把自己想用的一些不是特别敏感的参数放上</li>
  <li>$signature这部分才是重头戏，他是根据前两个+自己定义的secret加密成的token。之所以要用前两个参数参与加密，就是防止
    前两个参数被私自篡改。如果被改之后，第三个参数由于加密规则不符，所以可以失败</li>
</ul>

<h3>生成JWT</h3>
<p>下面是生成方法，最关键的是密钥部分</p>
<pre>
public function GetJwt()
{

  $header = base64_encode(json_encode(array(
      'typ' => 'JWT',
      'alg' => 'HS256'
  )));
  $playload = base64_encode(json_encode(array(
      "sub" => "1234567890",
      "name" => "夏天",
      "admin" => true
  )));
  $returnVal = $header.'.'.$playload;

  $signature =hash_hmac('sha256', $returnVal, 'secret');
  $returnVal.= '.'.$signature;

  return $returnVal;

}
</pre>
<h3>JWT验证</h3>
<p>这部分只是示例的做了一下，意思大概就是，我按照第二部分$playload的参数，重新生成一次JWT,然后再跟接收到的这个JWT进行比对，看是否一致</p>
<pre>
public function CkJwt($opt)
{
  $hashed_expected = $this-> GetJwt();
  $result = $this -> hash_compare($opt, $hashed_expected);

  return $result;

}
public function hash_compare($a, $b) {
  if (!is_string($a) || !is_string($b)) {
      return false;
  }

  $len = strlen($a);
  if ($len !== strlen($b)) {
      return false;
  }

  $status = 0;
  for ($i = 0; $i < $len; $i++) {
      $status |= ord($a[$i]) ^ ord($b[$i]);
  }
  return $status === 0;
}
</pre>
</body>
</html>
